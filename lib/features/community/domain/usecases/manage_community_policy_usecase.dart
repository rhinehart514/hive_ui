import 'package:hive_ui/features/community/domain/entities/community_policy_entity.dart';
import 'package:hive_ui/features/community/domain/repositories/community_policy_repository.dart';

/// Use case for managing community policies
class ManageCommunityPolicyUseCase {
  /// The community policy repository
  final CommunityPolicyRepository _repository;
  
  /// Constructor
  ManageCommunityPolicyUseCase(this._repository);
  
  /// Get a community policy by ID
  Future<CommunityPolicyEntity?> getPolicy(String policyId) async {
    return _repository.getPolicyById(policyId);
  }
  
  /// Get the active policy for a community
  Future<CommunityPolicyEntity?> getActivePolicy(String communityId) async {
    return _repository.getActivePolicyForCommunity(communityId);
  }
  
  /// Get all policies for a community
  Future<List<CommunityPolicyEntity>> getAllPolicies(String communityId) async {
    return _repository.getAllPoliciesForCommunity(communityId);
  }
  
  /// Create a new community policy
  Future<String> createPolicy({
    required String communityId,
    required String title,
    required String description,
    required String summary,
    required String version,
    List<CommunityRuleEntity> rules = const [],
    List<PolicyConsequenceEntity> consequences = const [],
    String? appealsProcess,
    bool isActive = false,
  }) async {
    final policy = CommunityPolicyEntity(
      id: '', // Will be generated by the repository
      communityId: communityId,
      title: title,
      description: description,
      summary: summary,
      lastUpdated: DateTime.now(),
      version: version,
      rules: rules,
      consequences: consequences,
      appealsProcess: appealsProcess,
      isActive: isActive,
    );
    
    return _repository.createPolicy(policy);
  }
  
  /// Update an existing community policy
  Future<void> updatePolicy({
    required String policyId,
    String? title,
    String? description,
    String? summary,
    String? version,
    List<CommunityRuleEntity>? rules,
    List<PolicyConsequenceEntity>? consequences,
    String? appealsProcess,
    bool? isActive,
  }) async {
    // First fetch the existing policy
    final existingPolicy = await _repository.getPolicyById(policyId);
    if (existingPolicy == null) {
      throw Exception('Policy not found');
    }
    
    // Create updated policy with new values
    final updatedPolicy = existingPolicy.copyWith(
      title: title,
      description: description,
      summary: summary,
      version: version,
      rules: rules,
      consequences: consequences,
      appealsProcess: appealsProcess,
      isActive: isActive,
      lastUpdated: DateTime.now(),
    );
    
    // Update the policy
    await _repository.updatePolicy(updatedPolicy);
    
    // If setting as active, ensure it's set as the active policy
    if (isActive == true) {
      await _repository.setActivePolicyForCommunity(
        communityId: updatedPolicy.communityId,
        policyId: policyId,
      );
    }
  }
  
  /// Delete a community policy
  Future<void> deletePolicy(String policyId) async {
    await _repository.deletePolicy(policyId);
  }
  
  /// Add a rule to a policy
  Future<void> addRule({
    required String policyId,
    required String title,
    required String description,
    required List<String> examples,
    required RuleSeverity severity,
    List<String> tags = const [],
    bool isActive = true,
  }) async {
    // Create a new rule
    final rule = CommunityRuleEntity(
      id: '', // Will be generated by the repository
      title: title,
      description: description,
      examples: examples,
      severity: severity,
      isActive: isActive,
      tags: tags,
    );
    
    // Add the rule to the policy
    await _repository.addRuleToPolicy(policyId: policyId, rule: rule);
  }
  
  /// Update a rule
  Future<void> updateRule({
    required String policyId,
    required String ruleId,
    String? title,
    String? description,
    List<String>? examples,
    RuleSeverity? severity,
    List<String>? tags,
    bool? isActive,
  }) async {
    // Get the policy to find the rule
    final policy = await _repository.getPolicyById(policyId);
    if (policy == null) {
      throw Exception('Policy not found');
    }
    
    // Find the existing rule
    final existingRuleIndex = policy.rules.indexWhere((r) => r.id == ruleId);
    if (existingRuleIndex == -1) {
      throw Exception('Rule not found in policy');
    }
    
    // Create updated rule
    final updatedRule = policy.rules[existingRuleIndex].copyWith(
      title: title,
      description: description,
      examples: examples,
      severity: severity,
      tags: tags,
      isActive: isActive,
    );
    
    // Update the rule
    await _repository.updateRule(policyId: policyId, rule: updatedRule);
  }
  
  /// Remove a rule from a policy
  Future<void> removeRule({
    required String policyId,
    required String ruleId,
  }) async {
    await _repository.removeRuleFromPolicy(policyId: policyId, ruleId: ruleId);
  }
  
  /// Add a consequence to a policy
  Future<void> addConsequence({
    required String policyId,
    required String title,
    required String description,
    required RuleSeverity severity,
    required int violationThreshold,
    Duration? duration,
    required bool isPermanent,
    required bool isAutomatic,
  }) async {
    // Create a new consequence
    final consequence = PolicyConsequenceEntity(
      id: '', // Will be generated by the repository
      title: title,
      description: description,
      severity: severity,
      violationThreshold: violationThreshold,
      duration: duration,
      isPermanent: isPermanent,
      isAutomatic: isAutomatic,
    );
    
    // Add the consequence to the policy
    await _repository.addConsequenceToPolicy(
      policyId: policyId,
      consequence: consequence,
    );
  }
  
  /// Update a consequence
  Future<void> updateConsequence({
    required String policyId,
    required String consequenceId,
    String? title,
    String? description,
    RuleSeverity? severity,
    int? violationThreshold,
    Duration? duration,
    bool? isPermanent,
    bool? isAutomatic,
  }) async {
    // Get the policy to find the consequence
    final policy = await _repository.getPolicyById(policyId);
    if (policy == null) {
      throw Exception('Policy not found');
    }
    
    // Find the existing consequence
    final existingConsequenceIndex = policy.consequences.indexWhere(
      (c) => c.id == consequenceId
    );
    if (existingConsequenceIndex == -1) {
      throw Exception('Consequence not found in policy');
    }
    
    // Create updated consequence
    final updatedConsequence = policy.consequences[existingConsequenceIndex].copyWith(
      title: title,
      description: description,
      severity: severity,
      violationThreshold: violationThreshold,
      duration: duration,
      isPermanent: isPermanent,
      isAutomatic: isAutomatic,
    );
    
    // Update the consequence
    await _repository.updateConsequence(
      policyId: policyId,
      consequence: updatedConsequence,
    );
  }
  
  /// Remove a consequence from a policy
  Future<void> removeConsequence({
    required String policyId,
    required String consequenceId,
  }) async {
    await _repository.removeConsequenceFromPolicy(
      policyId: policyId,
      consequenceId: consequenceId,
    );
  }
} 