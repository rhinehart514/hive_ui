import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:auto_route/auto_route.dart';
import 'package:hive_ui/features/spaces/presentation/providers/space_providers.dart';
import 'package:hive_ui/features/spaces/presentation/providers/spaces_controller.dart';
import 'package:hive_ui/features/spaces/presentation/providers/user_spaces_providers.dart' as user_providers;
import 'package:hive_ui/models/space.dart';
import 'package:hive_ui/models/space_type.dart';
import 'package:hive_ui/models/event.dart';
import 'package:hive_ui/models/event_creation_request.dart';
import 'package:hive_ui/theme/app_colors.dart';
import 'package:hive_ui/theme/huge_icons.dart';
import 'package:hive_ui/services/analytics_service.dart';
import 'package:flutter_staggered_animations/flutter_staggered_animations.dart';
import 'package:go_router/go_router.dart';
import 'package:hive_ui/providers/user_providers.dart';
import 'dart:math';
import 'dart:ui';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:hive_ui/core/navigation/routes.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:hive_ui/features/spaces/presentation/widgets/space_search_results.dart';
import 'package:hive_ui/features/spaces/presentation/widgets/spaces_search_bar.dart';
import 'package:hive_ui/features/spaces/presentation/providers/space_search_provider.dart';

// Custom FloatingActionButtonLocation that positions the FAB higher than the standard location
class _CustomFloatingActionButtonLocation extends FloatingActionButtonLocation {
  // Create a singleton instance
  static final _CustomFloatingActionButtonLocation endFloat = _CustomFloatingActionButtonLocation();

  @override
  Offset getOffset(ScaffoldPrelayoutGeometry scaffoldGeometry) {
    // Get the standard end float position
    final standardOffset = FloatingActionButtonLocation.endFloat.getOffset(scaffoldGeometry);
    
    // Return a new offset with the same horizontal position but higher by 80dp to avoid navigation bar
    // This provides better positioning that doesn't interfere with the bottom navigation bar
    return Offset(standardOffset.dx, standardOffset.dy - 80);
  }
}

@RoutePage()
class SpacesPage extends ConsumerStatefulWidget {
  const SpacesPage({super.key});

  @override
  ConsumerState<SpacesPage> createState() => _SpacesPageState();
}

class _SpacesPageState extends ConsumerState<SpacesPage>
    with TickerProviderStateMixin {
  final TextEditingController _searchController = TextEditingController();
  final FocusNode _searchFocusNode = FocusNode();
  bool _isSearchExpanded = false;
  final Set<String> _activeFilters = <String>{};
  bool _isJoiningSpace = false; // Keep this since it's used in the code
  int? _lastMySpacesRefreshTime; // Track when My Spaces tab was last refreshed

  // Scroll controllers
  final ScrollController _mainScrollController = ScrollController();
  final ScrollController _categoriesScrollController = ScrollController();
  final ScrollController _mySpacesScrollController = ScrollController();

  // Tab controller for explore/my spaces
  TabController? _tabController;

  String _activeCategory = 'All';
  bool _isRefreshing = false;
  bool _isLoadingMore = false;
  int _currentPage = 1;
  final int _spacesPerPage = 20;

  // Define space categories - condensed to most important for students
  final List<String> _categories = [
    'All',
    'Student Orgs',
    'Greek Life',
    'Campus Living',
    'University',
    'Hive Exclusive',
    'Academics',  // New locked category
    'Circles',    // New locked category
  ];

  // New method to build the custom spaces app bar
  PreferredSizeWidget _buildSpacesAppBar(BuildContext context) {
    return PreferredSize(
      preferredSize: Size.fromHeight(_isSearchExpanded ? 180 : 140), // Adjust height based on search state
      child: ClipRRect(
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 10, sigmaY: 10),
          child: Container(
            decoration: BoxDecoration(
              color: AppColors.black.withOpacity(0.7),
              border: const Border(
                bottom: BorderSide(
                  color: Colors.white10,
                  width: 0.5,
                ),
              ),
            ),
            child: SafeArea(
              child: Column(
                children: [
                  // Top section with title and actions
                  SizedBox(
                    height: 60,
                    child: Row(
                      children: [
                        const SizedBox(width: 16),
                        Text(
                          'Spaces',
                          style: GoogleFonts.outfit(
                            color: AppColors.white,
                            fontSize: 24,
                            fontWeight: FontWeight.w700,
                            letterSpacing: -0.5,
                          ),
                        ),
                        const Spacer(),
                        // Search icon
                        _isSearchExpanded
                            ? const SizedBox.shrink() // Don't show search button when expanded
                            : IconButton(
                                icon: const Icon(Icons.search, color: AppColors.white),
                                onPressed: () {
                                  HapticFeedback.selectionClick();
                                  setState(() {
                                    _toggleSearchExpanded(true);
                                  });
                                  Future.delayed(const Duration(milliseconds: 100), () {
                                    _searchFocusNode.requestFocus();
                                  });
                                },
                              ),
                        if (!_isSearchExpanded) ...[
                          // Messaging button with custom icon
                          GestureDetector(
                            onTap: () {
                              HapticFeedback.mediumImpact();
                              GoRouter.of(context).go(AppRoutes.messaging);
                            },
                            child: Container(
                              width: 44,
                              height: 44,
                              margin: const EdgeInsets.only(right: 16),
                              decoration: BoxDecoration(
                                color: Colors.transparent,
                                borderRadius: BorderRadius.circular(22),
                              ),
                              child: Icon(
                                HugeIcons.message,
                                color: AppColors.gold,
                                size: 28,
                              ),
                            ),
                          ),
                        ],
                      ],
                    ),
                  ),

                  // Search bar when expanded
                  SpacesSearchBar(
                    isSearching: _isSearchExpanded,
                    searchController: _searchController,
                    searchFocusNode: _searchFocusNode,
                    onSearchClosed: () {
                      setState(() {
                        _toggleSearchExpanded(false);
                      });
                    },
                  ),

                  // Tab bar
                  Container(
                    height: 48,
                    decoration: const BoxDecoration(
                      border: Border(
                        bottom: BorderSide(
                          color: Colors.white10,
                          width: 0.5,
                        ),
                      ),
                    ),
                    child: TabBar(
                      controller: _tabController,
                      labelColor: AppColors.gold,
                      unselectedLabelColor: AppColors.textTertiary,
                      indicatorColor: AppColors.gold,
                      indicatorWeight: 3,
                      indicatorSize: TabBarIndicatorSize.label,
                      labelStyle: GoogleFonts.outfit(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                      ),
                      unselectedLabelStyle: GoogleFonts.outfit(
                        fontSize: 16,
                        fontWeight: FontWeight.w500,
                      ),
                      tabs: const [
                        Tab(text: 'Explore'),
                        Tab(text: 'My Spaces'),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  @override
  void initState() {
    super.initState();
    
    // Initialize search state in provider
    Future.microtask(() {
      ref.read(spaceSearchActiveProvider.notifier).state = _isSearchExpanded;
    });
    
    // Refresh user data to ensure spaces are loaded
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(userProvider.notifier).refreshUserData();
      
      // Force refresh of user spaces data
      ref.invalidate(user_providers.userSpacesProvider);
      
      // Debug spaces loading
      final userData = ref.read(userProvider);
      if (userData != null) {
        debugPrint('SpacesPage: User has ${userData.joinedClubs.length} joined spaces: ${userData.joinedClubs}');
      } else {
        debugPrint('SpacesPage: No user data available');
      }
    });
    
    // Set up tab controller
    _tabController = TabController(
      length: 2,
      vsync: this,
    );
    
    // Add listener to handle tab changes
    _tabController!.addListener(_handleTabChange);
    
    // Setup scroll controllers for pagination
    _mainScrollController.addListener(_scrollListener);
    _mySpacesScrollController.addListener(_mySpacesScrollListener);

    // Load user data directly from Firebase
    _loadUserDataFromFirebase();

    // Log screen view
    AnalyticsService.logScreenView('spaces_page');
  }
  
  // Handle tab changes - close search if expanded
  void _handleTabChange() {
    if (_tabController?.indexIsChanging ?? false) {
      // Close search when switching tabs
      if (_isSearchExpanded) {
        _toggleSearchExpanded(false);
        _searchController.clear();
        
        // Move provider state update to microtask
        Future.microtask(() {
          ref.read(spaceSearchQueryProvider.notifier).state = '';
        });
      }
    }
  }

  // New method to load user data directly from Firebase
  Future<void> _loadUserDataFromFirebase() async {
    final user = FirebaseAuth.instance.currentUser;
    if (user == null) {
      debugPrint('⚠️ Cannot load user data: No authenticated user');
      return;
    }

    try {
      debugPrint('🔄 Loading user data directly from Firebase for user ${user.uid}');
      
      // Get the user document from Firestore
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(user.uid)
          .get();
      
      if (!userDoc.exists) {
        debugPrint('⚠️ User document does not exist in Firestore');
        return;
      }
      
      final data = userDoc.data();
      if (data == null) {
        debugPrint('⚠️ User document exists but has no data');
        return;
      }
      
      // Extract joined clubs and followed spaces
      List<String> joinedClubs = [];
      List<String> followedSpaces = [];
      
      if (data['joinedClubs'] is List) {
        joinedClubs = List<String>.from(data['joinedClubs']);
        debugPrint('📊 Found ${joinedClubs.length} joinedClubs in user document: $joinedClubs');
      }
      
      if (data['followedSpaces'] is List) {
        followedSpaces = List<String>.from(data['followedSpaces']);
        debugPrint('📊 Found ${followedSpaces.length} followedSpaces in user document: $followedSpaces');
      }
      
      // Combine both lists for maximum compatibility
      final allSpaceIds = {...joinedClubs, ...followedSpaces}.toList();
      
      if (allSpaceIds.isEmpty) {
        debugPrint('⚠️ User has no joined spaces in either joinedClubs or followedSpaces');
        return;
      }
      
      // Update the userProvider
      final currentUserData = ref.read(userProvider);
      if (currentUserData != null) {
        // Create updated user data with the joined clubs
        UserData updatedUserData = UserData(
          id: user.uid,
          name: user.displayName,
          email: user.email,
          joinedClubs: allSpaceIds,
          attendedEvents: currentUserData.attendedEvents,
          interests: currentUserData.interests,
        );
        
        // Update the provider - Use updateUserData instead of refreshUserData
        ref.read(userProvider.notifier).updateUserData(updatedUserData);
        debugPrint('✅ Updated userProvider with ${updatedUserData.joinedClubs.length} joined clubs');
        
        // Refresh spaces providers
        ref.invalidate(userSpacesProvider);
        
        // Also sync from Firebase to local
        final syncUserSpaces = ref.read(user_providers.syncUserSpacesProvider);
        syncUserSpaces();
      }
    } catch (e) {
      debugPrint('❌ Error loading user data from Firebase: $e');
    }
  }

  void _scrollListener() {
    if (!_isLoadingMore &&
        _mainScrollController.position.pixels >=
            _mainScrollController.position.maxScrollExtent * 0.8) {
      _loadMoreSpaces();
    }
  }

  // Scroll listener for My Spaces tab
  void _mySpacesScrollListener() {
    if (!_isLoadingMore &&
        _mySpacesScrollController.position.pixels >=
            _mySpacesScrollController.position.maxScrollExtent * 0.8) {
      // If needed, implement pagination for mySpaces tab
      // For now, we'll just log that scrolling is working
      debugPrint('Scrolled to bottom of My Spaces tab');
    }
  }

  Future<void> _loadMoreSpaces() async {
    if (_isLoadingMore) return;

    setState(() {
      _isLoadingMore = true;
    });

    try {
      // Load next page of spaces
      _currentPage++;
      await ref
          .read(spacesControllerProvider.notifier)
          .loadMoreSpaces(_currentPage, _spacesPerPage);

      // Small delay to prevent rapid multiple loads if the user is scrolling fast
      await Future.delayed(const Duration(milliseconds: 300));
    } catch (e) {
      debugPrint('Error loading more spaces: $e');
    } finally {
      if (mounted) {
        setState(() {
          _isLoadingMore = false;
        });
      }
    }
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    _mainScrollController.dispose();
    _categoriesScrollController.dispose();
    _mySpacesScrollController.dispose();
    // Safely dispose tab controller
    if (_tabController != null) {
      _tabController!.dispose();
    }
    super.dispose();
  }

  // Handle pull-to-refresh gesture
  Future<void> _refreshSpaces() async {
    try {
      debugPrint('Refreshing spaces data');
      
      // First call our new sync provider to ensure consistency between Firebase and local data
      final syncUserSpaces = ref.read(user_providers.syncUserSpacesProvider);
      await syncUserSpaces();
      debugPrint('User spaces data synchronized');
      
      // Refresh user data through the StateNotifier method
      await ref.read(userProvider.notifier).refreshUserData();
      debugPrint('User data refreshed');
      
      // Then refresh the spaces providers
      await ref.refresh(userSpacesProvider.future);
      await ref.refresh(hierarchicalSpacesProvider.future);
      await ref.refresh(trendingSpacesProvider.future);
      
      // For debugging: check what spaces we have after refresh
      final userData = ref.read(userProvider);
      debugPrint('After refresh: User has ${userData?.joinedClubs.length ?? 0} joined clubs: ${userData?.joinedClubs}');
      
      // Try to wait for the user spaces to be loaded and print what we got
      Future.delayed(const Duration(seconds: 1), () {
        final spacesAsync = ref.read(userSpacesProvider);
        spacesAsync.whenData((spaces) {
          debugPrint('UserSpacesProvider loaded ${spaces.length} spaces after refresh: ${spaces.map((s) => s.id).toList()}');
        });
      });
      
      setState(() {
        // Reset tab controller to ensure proper refresh
        if (_tabController != null && _tabController!.index == 1) {
          // When on My Spaces tab, store the current timestamp
          _lastMySpacesRefreshTime = DateTime.now().millisecondsSinceEpoch;
        }
      });
    } catch (e) {
      debugPrint('Error refreshing spaces: $e');
    }
  }

  // Handle space joining
  Future<void> _handleJoinSpace(Space space) async {
    if (_isJoiningSpace) return; // Prevent multiple simultaneous joins

    try {
      setState(() {
        _isJoiningSpace = true;
      });

      // Get current user
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        // Show sign-in message
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('You need to sign in to join spaces'),
              duration: Duration(seconds: 2),
            ),
          );
        }
        return;
      }

      // DIRECT APPROACH: Update Firebase directly
      debugPrint('DIRECT JOIN: Attempting to add space ${space.id} to user ${user.uid}');
      
      // 1. Update user document in Firestore
      try {
        await FirebaseFirestore.instance.collection('users').doc(user.uid).update({
          'followedSpaces': FieldValue.arrayUnion([space.id]),
          // Remove joinedClubs since that's obsolete and we only look at followedSpaces 
          'updatedAt': FieldValue.serverTimestamp(),
        });
        debugPrint('✅ Successfully updated user document with space ${space.id}');
      } catch (e) {
        debugPrint('❌ Failed to update user document: $e');
        throw e; // Re-throw to be caught by the outer try-catch
      }
      
      // 2. Update space document to increment member count
      try {
        // The Space object already has its type info through spaceType enum
        String? spacePath;
        String? spaceType;
        
        // Map SpaceType enum to the collection path name (same mapping as in _handleTapSpace)
        switch (space.spaceType) {
          case SpaceType.fraternityAndSorority:
            spaceType = 'fraternity_and_sorority';
            break;
          case SpaceType.universityOrg:
            spaceType = 'university_organizations';
            break;
          case SpaceType.campusLiving:
            spaceType = 'campus_living';
            break;
          case SpaceType.studentOrg:
            spaceType = 'student_organizations';
            break;
          case SpaceType.other:
            spaceType = 'other';
            // Try to determine from the Space's customData
            if (space.customData.containsKey('collectionType')) {
              spaceType = space.customData['collectionType'] as String;
            }
            break;
        }
        
        debugPrint('Space type from enum: ${space.spaceType}, mapped to: $spaceType');
        
        bool updated = false;
        
        // If we have the type, try updating with it
        if (spaceType != null) {
          try {
            await FirebaseFirestore.instance
                .collection('spaces')
                .doc(spaceType)
                .collection('spaces')  // Changed from 'space' to 'spaces' (plural)
                .doc(space.id)
                .update({
                  'memberCount': FieldValue.increment(1),
                  'updatedAt': FieldValue.serverTimestamp(),
                });
            updated = true;
            debugPrint('Updated space at path: spaces/$spaceType/spaces/${space.id}');
          } catch (e) {
            debugPrint('Failed to update space using type $spaceType: $e');
          }
        }
        
        // If we couldn't update using direct info, try each space type
        if (!updated) {
          final spaceTypes = [
            'campus_living',
            'fraternity_and_sorority',
            'student_organizations',
            'university_organizations',
            'other',
          ];
          
          for (final type in spaceTypes) {
            try {
              await FirebaseFirestore.instance
                  .collection('spaces')
                  .doc(type)
                  .collection('spaces')  // Changed from 'space' to 'spaces' (plural)
                  .doc(space.id)
                  .update({
                    'memberCount': FieldValue.increment(1),
                    'updatedAt': FieldValue.serverTimestamp(),
                  });
              updated = true;
              debugPrint('Updated space at path: spaces/$type/spaces/${space.id}');
              // Save this for the member addition
              spaceType = type;
              break;
            } catch (e) {
              // Continue to next type
            }
          }
        }
        
        // Use collection group as last resort
        if (!updated) {
          debugPrint('Trying collection group query as last resort');
          final spaceQuery = await FirebaseFirestore.instance
              .collectionGroup('spaces')  // Changed from 'space' to 'spaces' (plural)
              .where('id', isEqualTo: space.id)
              .limit(1)
              .get();
              
          if (spaceQuery.docs.isNotEmpty) {
            await spaceQuery.docs.first.reference.update({
              'memberCount': FieldValue.increment(1),
              'updatedAt': FieldValue.serverTimestamp(),
            });
            updated = true;
            spacePath = spaceQuery.docs.first.reference.path;
            debugPrint('Updated space using collection group: $spacePath');
          }
        }
        
        if (!updated) {
          debugPrint('Failed to update space ${space.id} after all attempts');
        }
      
        // 3. Add user to space members collection
        bool memberAdded = false;
        
        // Use the path or type we found earlier
        if (spacePath != null) {
          try {
            final docRef = FirebaseFirestore.instance.doc(spacePath);
            await docRef.collection('members').doc(user.uid).set({
              'userId': user.uid,
              'joinedAt': FieldValue.serverTimestamp(),
              'status': 'active',
            });
            memberAdded = true;
            debugPrint('Added user to members at path: $spacePath/members');
          } catch (e) {
            debugPrint('Failed to add member using direct path: $e');
          }
        } else if (spaceType != null) {
          try {
            await FirebaseFirestore.instance
                .collection('spaces')
                .doc(spaceType)
                .collection('spaces')
                .doc(space.id)
                .collection('members')
                .doc(user.uid)
                .set({
                  'userId': user.uid,
                  'joinedAt': FieldValue.serverTimestamp(),
                  'status': 'active',
                });
            memberAdded = true;
            debugPrint('Added user to members at path: spaces/$spaceType/spaces/${space.id}/members');
          } catch (e) {
            debugPrint('Failed to add member using space type: $e');
          }
        }
        
        if (!memberAdded) {
          debugPrint('⚠️ Warning: Failed to add user to space members collection after all attempts');
        }

        // 4. Update the local user provider state to show this space as joined immediately
        final userData = ref.read(userProvider);
        if (userData != null) {
          // Use the joinClub method to update joinedClubs array
          ref.read(userProvider.notifier).state = userData.joinClub(space.id);
          debugPrint('✅ Updated local user provider with space ${space.id}');
          debugPrint('User now has ${userData.joinClub(space.id).joinedClubs.length} joined clubs: ${userData.joinClub(space.id).joinedClubs}');
        }

        // 5. Force refresh of spaces providers to update UI
        ref.invalidate(userSpacesProvider);
        ref.invalidate(hierarchicalSpacesProvider);
        if (_tabController?.index == 1) {
          // If already on My Spaces tab, save this timestamp
          _lastMySpacesRefreshTime = DateTime.now().millisecondsSinceEpoch;
        }

        // Success! Show a confirmation
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('You\'ve joined ${space.name}'),
              duration: const Duration(seconds: 2),
            ),
          );
        }
        
        // Check the userProvider state after a short delay 
        Future.delayed(const Duration(milliseconds: 500), () {
          final updatedUserData = ref.read(userProvider);
          debugPrint('After join operation: User has ${updatedUserData?.joinedClubs.length ?? 0} joined clubs: ${updatedUserData?.joinedClubs}');
          
          // Also check if the space appears in userSpacesProvider
          final spacesAsync = ref.read(userSpacesProvider);
          spacesAsync.whenData((spaces) {
            debugPrint('After join: UserSpacesProvider has ${spaces.length} spaces: ${spaces.map((s) => s.id).toList()}');
            final isSpaceFound = spaces.any((s) => s.id == space.id);
            debugPrint('Is joined space (${space.id}) found in userSpacesProvider? $isSpaceFound');
            
            // If not found, trigger the sync provider
            if (!isSpaceFound) {
              debugPrint('Space not found in userSpacesProvider. Triggering sync...');
              final syncUserSpaces = ref.read(user_providers.syncUserSpacesProvider);
              syncUserSpaces().then((_) {
                debugPrint('Sync completed. Checking again...');
                // Invalidate providers to force refresh
                ref.invalidate(userSpacesProvider);
                
                // Check again after sync
                Future.delayed(const Duration(milliseconds: 500), () {
                  final reloadedSpaces = ref.read(userSpacesProvider);
                  reloadedSpaces.whenData((spaces) {
                    final isSpaceFoundAfterSync = spaces.any((s) => s.id == space.id);
                    debugPrint('After sync: Is space (${space.id}) found in userSpacesProvider? $isSpaceFoundAfterSync');
                    if (!isSpaceFoundAfterSync) {
                      debugPrint('⚠️ WARNING: Space still not found after sync. Manual Firestore update might be needed.');
                    }
                  });
                });
              });
            }
          });
        });
      } catch (e) {
        debugPrint('Error updating space: $e');
        // Try collection group as final fallback
        try {
          final spaceQuery = await FirebaseFirestore.instance
              .collectionGroup('space')
              .where('id', isEqualTo: space.id)
              .limit(1)
              .get();
              
          if (spaceQuery.docs.isNotEmpty) {
            await spaceQuery.docs.first.reference.update({
              'memberCount': FieldValue.increment(1),
              'updatedAt': FieldValue.serverTimestamp(),
            });
            debugPrint('Updated space using collection group query: ${spaceQuery.docs.first.reference.path}');
          }
        } catch (fallbackError) {
          debugPrint('Collection group query also failed: $fallbackError');
        }
      }
      
      debugPrint('DIRECT JOIN: Successfully updated Firestore');
      
      // Update the local user data for immediate reflection
      final userData = ref.read(userProvider);
      if (userData != null) {
        debugPrint('DIRECT JOIN: Updating local user data');
        // Use the existing joinClub method which works with joinedClubs
        ref.read(userProvider.notifier).state = userData.joinClub(space.id);
      }
      
      // Force providers to refresh
      ref.invalidate(userSpacesProvider);
      ref.invalidate(userProvider);
      
      // Wait a moment for state to update
      await Future.delayed(const Duration(milliseconds: 500));

      // Show success message
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Successfully joined ${space.name}'),
            duration: const Duration(seconds: 2),
          ),
        );
      }

      // Switch to My Spaces tab to show the newly joined space
      if (_tabController != null && mounted) {
        _tabController!.animateTo(1); // My Spaces tab
        
        // Force an additional refresh after tab switch
        Future.delayed(const Duration(milliseconds: 200), () {
          if (mounted) {
            ref.invalidate(userSpacesProvider);
            debugPrint('DIRECT JOIN: Forced refresh after tab switch');
          }
        });
      }
    } catch (e) {
      debugPrint('Error joining space: $e');
      // Show error message
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to join space: ${e.toString().split('\n').first}'),
            duration: const Duration(seconds: 3),
          ),
        );
      }
    } finally {
      setState(() {
        _isJoiningSpace = false;
      });
    }
  }

  // Show dialog to join or create a space
  void _showJoinSpaceDialog(BuildContext context) {
    HapticFeedback.mediumImpact();

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          backgroundColor: Colors.grey[900],
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
          title: Text(
            'Join or Create a Space',
            style: GoogleFonts.outfit(
              color: Colors.white,
              fontWeight: FontWeight.w600,
            ),
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'Would you like to join an existing space or create a new one?',
                style: GoogleFonts.inter(
                  color: Colors.white70,
                  fontSize: 14,
                ),
              ),
              const SizedBox(height: 24),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: OutlinedButton(
                      onPressed: () {
                        Navigator.of(context).pop();
                        // Navigate to join space view
                      },
                      style: OutlinedButton.styleFrom(
                        foregroundColor: AppColors.gold,
                        side: const BorderSide(color: AppColors.gold),
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                      child: Text(
                        'Join',
                        style: GoogleFonts.outfit(fontWeight: FontWeight.w500),
                      ),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: ElevatedButton(
                      onPressed: () {
                        Navigator.of(context).pop();
                        // Navigate to create space page
                        GoRouter.of(context).push(AppRoutes.getCreateSpacePath());
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: AppColors.gold,
                        foregroundColor: Colors.black,
                        padding: const EdgeInsets.symmetric(vertical: 12),
                      ),
                      child: Text(
                        'Create',
                        style: GoogleFonts.outfit(fontWeight: FontWeight.w600),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        );
      },
    );
  }

  // Note: The old space creation dialog has been completely replaced with a dedicated page
  // approach that provides a better user experience with more validation and features.

  // Helper to build dropdown items with icons for space types
  DropdownMenuItem<SpaceType> _buildSpaceTypeDropdownItem(
      SpaceType type, String text, IconData icon) {
    return DropdownMenuItem<SpaceType>(
      value: type,
      child: Row(
        children: [
          Icon(
            icon,
            color: AppColors.gold.withOpacity(0.7),
            size: 18,
          ),
          const SizedBox(width: 12),
          Text(
            text,
            style: GoogleFonts.inter(color: Colors.white),
          ),
        ],
      ),
    );
  }

  // Create a new space - removed in favor of the dedicated create space page

  // Handle space tapping
  void _handleTapSpace(Space space) {
    HapticFeedback.mediumImpact();
    try {
      // Format the club ID correctly to match the fallback format and ensure proper permissions
      // The path should match what's allowed in the security rules
      // ignore: unnecessary_null_comparison
      String spaceType;
      // Use the correct collection path format based on space type
      switch (space.spaceType) {
        case SpaceType.fraternityAndSorority:
          spaceType = 'fraternity_and_sorority';
          break;
        case SpaceType.universityOrg:
          spaceType = 'university_organizations';
          break;
        case SpaceType.campusLiving:
          spaceType = 'campus_living';
          break;
        case SpaceType.studentOrg:
          spaceType = 'student_organizations';
          break;
        case SpaceType.other:
          spaceType = 'other';
          break;
      }

      final String clubId = space.id.contains('space_')
          ? space.id
          : 'space_${space.name.toLowerCase().replaceAll(' ', '_')}';

      debugPrint(
          'Navigating to club space with ID: $clubId (type: $spaceType)');

      // Navigate to club space using GoRouter with the formatted ID
      GoRouter.of(context).push('/spaces/club?id=$clubId&type=$spaceType');

      // Log analytics
      AnalyticsService.logEvent(
        'view_space',
        parameters: {
          'space_id': space.id,
          'space_name': space.name,
          'space_type': space.spaceType.toString(),
        },
      );
    } catch (e) {
      debugPrint('Error navigating to space: $e');
      // Show error snackbar
      if (mounted) {
        String errorMessage = 'Error opening space';

        // Check if this is a permission error and provide a more helpful message
        if (e.toString().contains('permission-denied') ||
            e.toString().contains('PERMISSION_DENIED')) {
          errorMessage =
              'Permission denied. Please try again later or contact support.';
        }

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.red[700],
            duration: const Duration(seconds: 3),
            action: SnackBarAction(
              label: 'OK',
              textColor: Colors.white,
              onPressed: () {},
            ),
          ),
        );
      }
    }
  }

  // Add a wrapper to fix the async data issue in the tab controller
  void _performTabNavigation(int tab) {
    if (_tabController != null) {
      // Check that _tabController is initialized
      _tabController!.animateTo(tab);
    }
  }

  @override
  Widget build(BuildContext context) {
    // Watch necessary providers
    final spacesAsyncValue = ref.watch(spacesProvider);
    final userSpacesAsyncValue = ref.watch(user_providers.userSpacesProvider);
    
    // Read the search state instead of setting it directly in build
    final isSearchExpanded = ref.watch(spaceSearchActiveProvider);

    return Scaffold(
      backgroundColor: AppColors.black,
      appBar: _buildSpacesAppBar(context),
      body: Stack(
        children: [
          TabBarView(
            controller: _tabController,
            children: [
              // Explore tab
              RefreshIndicator(
                color: AppColors.gold,
                backgroundColor: Colors.black.withOpacity(0.7),
                onRefresh: _refreshSpaces,
                child: _buildExploreTab(ref.watch(hierarchicalSpacesProvider)),
              ),
              
              // My Spaces tab
              RefreshIndicator(
                color: AppColors.gold,
                backgroundColor: Colors.black.withOpacity(0.7),
                onRefresh: _refreshSpaces,
                child: _buildMySpacesTab(ref.watch(userSpacesProvider)),
              ),
            ],
          ),
          
          // Overlay the search results when search is active
          if (_isSearchExpanded)
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              child: SpaceSearchResults(),
            ),
        ],
      ),
      // Always create the FAB, but make it invisible if not in My Spaces tab
      floatingActionButton: FloatingActionButton.extended(
        backgroundColor: AppColors.gold,
        foregroundColor: Colors.black,
        onPressed: () => _showCreateSpaceDialog(context),
        icon: const Icon(Icons.add),
        label: const Text('Create Space'),
        elevation: 4,
      ),
      floatingActionButtonLocation: _CustomFloatingActionButtonLocation.endFloat,
    );
  }

  // Update state provider synchronization for search status
  void _updateSearchStateProvider() {
    final currentState = ref.read(spaceSearchActiveProvider);
    if (currentState != _isSearchExpanded) {
      // Use Future.microtask to update the provider state outside build cycle
      Future.microtask(() {
        ref.read(spaceSearchActiveProvider.notifier).state = _isSearchExpanded;
      });
    }
  }
  
  // Override didUpdateWidget to update provider when local state changes
  @override
  void didUpdateWidget(SpacesPage oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Update search state provider directly
    Future.microtask(() {
      if (mounted) {
        ref.read(spaceSearchActiveProvider.notifier).state = _isSearchExpanded;
      }
    });
  }
  
  // Also update in setState where _isSearchExpanded is modified
  void _toggleSearchExpanded(bool expanded) {
    if (_isSearchExpanded != expanded) {
      setState(() {
        _isSearchExpanded = expanded;
      });
      
      // Use Future.microtask to update provider outside build cycle
      Future.microtask(() {
        ref.read(spaceSearchActiveProvider.notifier).state = expanded;
        if (!expanded) {
          ref.read(spaceSearchQueryProvider.notifier).state = '';
        }
      });
    }
  }

  // Explore tab view
  Widget _buildExploreTab(AsyncValue<Map<String, List<Space>>> allSpaces) {
    return CustomScrollView(
      controller: _mainScrollController,
      physics: const AlwaysScrollableScrollPhysics(),
      slivers: [
        // Remove category selector from here as it will be moved to the All Spaces header

        // Trending spaces section
        SliverToBoxAdapter(
          child: _buildTrendingSpaces(ref.watch(trendingSpacesProvider)),
        ),

        // Recommended spaces section
        SliverToBoxAdapter(
          child: _buildRecommendedSpaces(allSpaces),
        ),

        // Main spaces grid
        _buildSpacesGrid(allSpaces),
      ],
    );
  }

  // My Spaces tab view
  Widget _buildMySpacesTab(AsyncValue<List<Space>> userSpaces) {
    // Force a refresh of the userSpacesProvider when this tab is visible
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_tabController?.index == 1) {
        // Always refresh when tab becomes visible
        final currentTime = DateTime.now().millisecondsSinceEpoch;
        final lastRefreshTime = _lastMySpacesRefreshTime ?? 0;
        final timeSinceLastRefresh = currentTime - lastRefreshTime;
        
        // Refresh immediately if it's been more than 5 seconds since last refresh
        if (timeSinceLastRefresh > 5000) {
          _lastMySpacesRefreshTime = currentTime;
          debugPrint('Auto-refreshing My Spaces tab (${userSpaces.value?.length ?? 0} spaces)');
          
          // Check current user data before refresh
          final userData = ref.read(userProvider);
          debugPrint('Before refresh: User has ${userData?.joinedClubs.length ?? 0} joined clubs: ${userData?.joinedClubs}');
          
          // Refresh both providers to ensure data consistency
          ref.invalidate(userSpacesProvider);
          
          // Let's explicitly fetch user data with Firebase
          ref.read(userProvider.notifier).refreshUserData();
          
          // Check what happens after the refresh with a delay
          Future.delayed(const Duration(milliseconds: 500), () {
            final updatedUserData = ref.read(userProvider);
            debugPrint('After auto-refresh: User has ${updatedUserData?.joinedClubs.length ?? 0} joined clubs: ${updatedUserData?.joinedClubs}');
            
            final spacesAsync = ref.read(userSpacesProvider);
            spacesAsync.whenData((spaces) {
              debugPrint('After auto-refresh: UserSpacesProvider loaded ${spaces.length} spaces: ${spaces.map((s) => s.id).toList()}');
            });
          });
        }
      }
    });
    
    // Get current user data to check for spaces
    final userData = ref.watch(userProvider);
    final joinedSpaceIds = userData?.joinedClubs ?? [];
    
    // If user has no spaces in userData but userSpaces is loading, show loading
    if (joinedSpaceIds.isEmpty && userSpaces is AsyncLoading) {
      return const Center(
        child: CircularProgressIndicator(color: AppColors.gold),
      );
    }
    
    // If user has spaces in userData but userSpaces provider failed, show direct from userData
    if (joinedSpaceIds.isNotEmpty && userSpaces is AsyncError) {
      debugPrint('UserSpacesProvider error, falling back to direct space lookup for ${joinedSpaceIds.length} spaces');
      // We'll try to load spaces directly from spacesProvider
      final allSpacesAsync = ref.watch(spacesProvider);
      
      return allSpacesAsync.when(
        data: (allSpaces) {
          // Filter to only show user's joined spaces
          final mySpaces = allSpaces.where((space) => joinedSpaceIds.contains(space.id)).toList();
          debugPrint('Fallback method found ${mySpaces.length} spaces from user joinedClubs');
          
          if (mySpaces.isEmpty) {
            return _buildEmptyMySpaces();
          }
          
          // Use SingleChildScrollView with AlwaysScrollableScrollPhysics as a wrapper
          return _buildMySpacesContent(mySpaces);
        },
        loading: () => const Center(
          child: CircularProgressIndicator(color: AppColors.gold),
        ),
        error: (error, stack) => Center(
          child: SingleChildScrollView(
            physics: const AlwaysScrollableScrollPhysics(),
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.error_outline,
                    color: Colors.red[300],
                    size: 48,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Unable to load your spaces',
                    style: GoogleFonts.outfit(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                      color: Colors.white,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Pull down to try again',
                    style: GoogleFonts.inter(
                      fontSize: 14,
                      color: Colors.white70,
                    ),
                  ),
                  const SizedBox(height: 24),
                  OutlinedButton(
                    onPressed: _refreshSpaces,
                    style: OutlinedButton.styleFrom(
                      foregroundColor: AppColors.gold,
                      side: const BorderSide(color: AppColors.gold),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                      padding:
                          const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                    ),
                    child: Text(
                      'Retry',
                      style: GoogleFonts.inter(fontWeight: FontWeight.w500),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }
    
    // Normal flow - use userSpaces provider
    return userSpaces.when(
      data: (spaces) {
        debugPrint('My Spaces tab displaying ${spaces.length} spaces: ${spaces.map((s) => s.id).toList()}');
        if (spaces.isEmpty) {
          return _buildEmptyMySpaces();
        }

        return _buildMySpacesContent(spaces);
      },
      loading: () => const Center(
        child: CircularProgressIndicator(color: AppColors.gold),
      ),
      error: (error, stackTrace) {
        debugPrint('Error displaying spaces: $error\n$stackTrace');
        return Center(
          child: SingleChildScrollView(
            physics: const AlwaysScrollableScrollPhysics(),
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.error_outline,
                    color: Colors.red[300],
                    size: 48,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Unable to load your spaces',
                    style: GoogleFonts.outfit(
                      fontSize: 18,
                      fontWeight: FontWeight.w600,
                      color: Colors.white,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Pull down to try again',
                    style: GoogleFonts.inter(
                      fontSize: 14,
                      color: Colors.white70,
                    ),
                  ),
                  const SizedBox(height: 24),
                  OutlinedButton(
                    onPressed: _refreshSpaces,
                    style: OutlinedButton.styleFrom(
                      foregroundColor: AppColors.gold,
                      side: const BorderSide(color: AppColors.gold),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                      padding:
                          const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                    ),
                    child: Text(
                      'Retry',
                      style: GoogleFonts.inter(fontWeight: FontWeight.w500),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
  
  // Common builder for My Spaces content
  Widget _buildMySpacesContent(List<Space> spaces) {
    // Get current user ID
    final currentUserId = FirebaseAuth.instance.currentUser?.uid;
    
    // Fetch all spaces to find those where user is an admin but hasn't joined
    if (currentUserId != null) {
      // Using a consumer to watch the spacesProvider 
      return Consumer(
        builder: (context, ref, child) {
          final allSpacesAsync = ref.watch(spacesProvider);
          
          return allSpacesAsync.when(
            data: (allSpaces) {
              // Find spaces where the user is an admin (leader)
              final adminSpaces = allSpaces
                  .where((space) => space.admins.contains(currentUserId) && !spaces.any((s) => s.id == space.id))
                  .toList();
              
              // Combine user's joined spaces with spaces they lead
              final combinedSpaces = [...spaces, ...adminSpaces];
              debugPrint('Showing ${spaces.length} joined spaces and ${adminSpaces.length} admin spaces');
              
              return CustomScrollView(
                controller: _mySpacesScrollController,
                physics: const AlwaysScrollableScrollPhysics(),
                slivers: [
                  SliverPadding(
                    padding: const EdgeInsets.all(16),
                    sliver: SliverList(
                      delegate: SliverChildBuilderDelegate(
                        (context, index) {
                          if (index < combinedSpaces.length) {
                            final space = combinedSpaces[index];
                            final isAdminOnly = !spaces.any((s) => s.id == space.id);
                            
                            return AnimationConfiguration.staggeredList(
                              position: index,
                              duration: const Duration(milliseconds: 375),
                              child: SlideAnimation(
                                verticalOffset: 50,
                                child: FadeInAnimation(
                                  child: Stack(
                                    children: [
                                      _buildSpaceListItem(
                                        space, 
                                        index,
                                        inMySpaces: true
                                      ),
                                      // Show leader badge for spaces where user is admin only
                                      if (isAdminOnly)
                                        Positioned(
                                          top: 8,
                                          right: 8,
                                          child: Container(
                                            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                            decoration: BoxDecoration(
                                              color: AppColors.gold,
                                              borderRadius: BorderRadius.circular(12),
                                            ),
                                            child: Row(
                                              mainAxisSize: MainAxisSize.min,
                                              children: [
                                                const Icon(
                                                  Icons.star,
                                                  color: Colors.black,
                                                  size: 12,
                                                ),
                                                const SizedBox(width: 4),
                                                Text(
                                                  'LEADER',
                                                  style: GoogleFonts.inter(
                                                    fontSize: 10,
                                                    fontWeight: FontWeight.bold,
                                                    color: Colors.black,
                                                  ),
                                                ),
                                              ],
                                            ),
                                          ),
                                        ),
                                    ],
                                  ),
                                ),
                              ),
                            );
                          }
                          return null;
                        },
                        childCount: combinedSpaces.length,
                      ),
                    ),
                  ),
                  // Adding bottom padding to ensure FAB doesn't overlap with the last item
                  const SliverToBoxAdapter(
                    child: SizedBox(height: 80),
                  ),
                ],
              );
            },
            loading: () => const Center(
              child: CircularProgressIndicator(color: AppColors.gold),
            ),
            error: (error, stack) => Center(
              child: Text('Error loading spaces: $error'),
            ),
          );
        },
      );
    } else {
      // Fallback for when user isn't authenticated
      return CustomScrollView(
        controller: _mySpacesScrollController,
        physics: const AlwaysScrollableScrollPhysics(),
        slivers: [
          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  if (index < spaces.length) {
                    return AnimationConfiguration.staggeredList(
                      position: index,
                      duration: const Duration(milliseconds: 375),
                      child: SlideAnimation(
                        verticalOffset: 50,
                        child: FadeInAnimation(
                          child: _buildSpaceListItem(
                              spaces[index], index,
                              inMySpaces: true),
                        ),
                      ),
                    );
                  }
                  return null;
                },
                childCount: spaces.length,
              ),
            ),
          ),
          // Adding bottom padding to ensure FAB doesn't overlap with the last item
          const SliverToBoxAdapter(
            child: SizedBox(height: 80),
          ),
        ],
      );
    }
  }

  // Empty state for My Spaces tab with enhanced design
  Widget _buildEmptyMySpaces() {
    return SingleChildScrollView(
      physics: const AlwaysScrollableScrollPhysics(),
      child: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Styled container with animation
              TweenAnimationBuilder<double>(
                duration: const Duration(seconds: 2),
                tween: Tween<double>(begin: 0.5, end: 1.0),
                curve: Curves.easeInOut,
                builder: (context, value, child) {
                  return Container(
                    width: 100,
                    height: 100,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      color: Colors.black,
                      border: Border.all(
                        color: AppColors.gold.withOpacity(0.3 + (0.3 * value)),
                        width: 2,
                      ),
                      boxShadow: [
                        BoxShadow(
                          color: AppColors.gold.withOpacity(0.1 + (0.2 * value)),
                          blurRadius: 15 * value,
                          spreadRadius: 2 * value,
                        ),
                      ],
                    ),
                    child: Center(
                      child: HugeIcon(
                        icon: HugeIcons.strokeRoundedUserGroup03,
                        size: 40,
                        color: AppColors.gold.withOpacity(0.7 + (0.3 * value)),
                      ),
                    ),
                  );
                },
              ),
              const SizedBox(height: 28),
              Text(
                'No Spaces Yet',
                style: GoogleFonts.outfit(
                  fontSize: 22,
                  fontWeight: FontWeight.w600,
                  color: Colors.white,
                  letterSpacing: 0.3,
                ),
              ),
              const SizedBox(height: 16),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 24),
                child: Text(
                  'Create your own space to connect with other students or join existing ones to discover events and communities.',
                  textAlign: TextAlign.center,
                  style: GoogleFonts.inter(
                    fontSize: 15,
                    color: Colors.white70,
                    height: 1.4,
                  ),
                ),
              ),
              // "Create a Space" button removed since we now have the FAB
            ],
          ),
        ),
      ),
    );
  }

  // Build category selector with improved design
  Widget _buildCategorySelector() {
    return ListView.builder(
        controller: _categoriesScrollController,
        scrollDirection: Axis.horizontal,
      padding: const EdgeInsets.only(left: 16, right: 16),
      physics: const BouncingScrollPhysics(),
        itemCount: _categories.length,
        itemBuilder: (context, index) {
          final category = _categories[index];
          final isActive = _activeCategory == category;

        // Assign appropriate HugeIcon based on category
        IconData categoryIcon;
          switch (category) {
            case 'All':
            categoryIcon = HugeIcons.home;
              break;
            case 'Student Orgs':
            categoryIcon = HugeIcons.strokeRoundedUserGroup03;
              break;
            case 'Greek Life':
            categoryIcon = HugeIcons.strokeRoundedAlphabetGreek;
              break;
            case 'Campus Living':
            categoryIcon = HugeIcons.strokeRoundedHouse03;
              break;
            case 'University':
            categoryIcon = HugeIcons.strokeRoundedMortarboard02;
            break;
            case 'Hive Exclusive':
              categoryIcon = Icons.workspace_premium;
              break;
          default:
            categoryIcon = HugeIcons.tag;
              break;
          }

        return GestureDetector(
                  onTap: () {
            HapticFeedback.selectionClick();
                    setState(() {
                      _activeCategory = category;
                    });
            
            // Optional: scroll to make selected category visible in center
            WidgetsBinding.instance.addPostFrameCallback((_) {
              if (_categoriesScrollController.hasClients) {
                // Calculate the item's approximate position
                final screenWidth = MediaQuery.of(context).size.width;
                const itemWidth = 100; // Approximate average width 
                final offset = index * itemWidth - (screenWidth / 2) + (itemWidth / 2);
                
                // Ensure the offset is within bounds
                final maxScrollExtent = _categoriesScrollController.position.maxScrollExtent;
                final scrollOffset = offset.clamp(0.0, maxScrollExtent);
                
                _categoriesScrollController.animateTo(
                  scrollOffset,
                  duration: const Duration(milliseconds: 300),
                  curve: Curves.easeInOut,
                );
              }
            });

                    // Animate scroll to top when changing categories
                    if (_mainScrollController.hasClients) {
                      _mainScrollController.animateTo(
                        0,
                        duration: const Duration(milliseconds: 300),
                        curve: Curves.easeInOut,
                      );
                    }
                  },
                  child: Container(
            margin: const EdgeInsets.only(right: 8),
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(20),
                      border: Border.all(
                color: isActive
                    ? AppColors.gold
                    : Colors.white.withOpacity(0.15),
                width: isActive ? 1.5 : 1,
              ),
              gradient: isActive
                  ? LinearGradient(
                      colors: [
                        Colors.black,
                        AppColors.gold.withOpacity(0.15),
                      ],
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                    )
                  : null,
              color: isActive ? null : Colors.black.withOpacity(0.3),
                      boxShadow: isActive
                          ? [
                              BoxShadow(
                        color: AppColors.gold.withOpacity(0.15),
                        blurRadius: 8,
                                spreadRadius: 0,
                              ),
                            ]
                          : null,
                    ),
                    child: Row(
              mainAxisSize: MainAxisSize.min,
                      children: [
                HugeIcon(
                  icon: categoryIcon,
                  size: 14,
                          color: isActive ? AppColors.gold : Colors.white70,
                        ),
                        const SizedBox(width: 6),
                        Text(
                          category,
                          style: GoogleFonts.outfit(
                            color: isActive ? AppColors.gold : Colors.white,
                    fontWeight: isActive ? FontWeight.w600 : FontWeight.w400,
                    fontSize: 13,
                          ),
                        ),
                      ],
              ),
            ),
          );
        },
    );
  }

  // Build trending spaces section with enhanced design
  Widget _buildTrendingSpaces(AsyncValue<List<Space>> trendingSpaces) {
    return trendingSpaces.when(
      data: (spaces) {
        // Filter spaces - only show Student Organizations and Greek Life in trending
        final filteredSpaces = spaces.where((space) {
          // Only allow StudentOrg and Fraternity/Sorority space types to appear in trending
          return space.spaceType == SpaceType.studentOrg ||
              space.spaceType == SpaceType.fraternityAndSorority;
        }).toList();

        if (filteredSpaces.isEmpty) {
          return const SizedBox.shrink();
        }

        // Sort by engagement score (higher scores first)
        filteredSpaces.sort((a, b) {
          // Use the dedicated engagementScore field
          final aEngagement = a.metrics.engagementScore;
          final bEngagement = b.metrics.engagementScore;
          return bEngagement.compareTo(aEngagement);
        });

        return Container(
          margin: const EdgeInsets.only(top: 8),
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                Colors.black,
                Colors.grey[900]!.withOpacity(0.3),
              ],
            ),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                padding: const EdgeInsets.fromLTRB(20, 20, 20, 12),
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(6),
                      decoration: BoxDecoration(
                        color: AppColors.gold.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Icon(
                        Icons.trending_up,
                        size: 16,
                        color: AppColors.gold,
                      ),
                    ),
                    const SizedBox(width: 10),
                    Text(
                      'Trending Spaces',
                      style: GoogleFonts.outfit(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                        letterSpacing: 0.2,
                      ),
                    ),
                    const Spacer(),
                    TextButton(
                      onPressed: () {
                        // View all trending spaces
                        HapticFeedback.selectionClick();
                        // Navigate to full trending view or use filter
                      },
                      style: TextButton.styleFrom(
                        foregroundColor: AppColors.gold,
                        padding: const EdgeInsets.symmetric(
                            horizontal: 12, vertical: 6),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(20),
                        ),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            'See All',
                            style: GoogleFonts.inter(
                              fontSize: 12,
                              fontWeight: FontWeight.w500,
                            ),
                          ),
                          const SizedBox(width: 4),
                          const Icon(
                            Icons.arrow_forward_ios,
                            size: 10,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              SizedBox(
                height: 140,
                child: ListView.builder(
                  scrollDirection: Axis.horizontal,
                  padding: const EdgeInsets.only(left: 20, right: 8),
                  itemCount: filteredSpaces.length,
                  itemBuilder: (context, index) {
                    final space = filteredSpaces[index];
                    // Pass the trending rank (1-based) to show "#X trending"
                    final trendingRank = index < 10 ? index + 1 : null;

                    // Assign different labels based on position and randomness
                    String? specialLabel;
                    Color? labelColor;
                    if (trendingRank == 1) {
                      specialLabel = "#1 Trending";
                      labelColor = AppColors.gold;
                    } else if (trendingRank != null && trendingRank < 4) {
                      specialLabel = "Rising Fast";
                      labelColor = Colors.orange[300];
                    } else if (trendingRank != null &&
                        Random().nextInt(5) == 0) {
                      specialLabel = "Popular";
                      labelColor = Colors.blue[300];
                    }

                    return Padding(
                      padding: const EdgeInsets.only(right: 16),
                      child: SizedBox(
                        width: 180,
                        child: AnimationConfiguration.staggeredList(
                          position: index,
                          duration: const Duration(milliseconds: 375),
                          child: SlideAnimation(
                            horizontalOffset: 50,
                            child: FadeInAnimation(
                              child: _buildMySpaceCard(
                                space,
                                trendingRank: trendingRank,
                                specialLabel: specialLabel,
                                labelColor: labelColor,
                                hasGlowEffect:
                                    index < 3, // Add glow effect to top 3
                              ),
                            ),
                          ),
                        ),
                      ),
                    );
                  },
                ),
              ),
              const SizedBox(height: 16),
            ],
          ),
        );
      },
      loading: () => const SizedBox(
        height: 0,
      ),
      error: (_, __) => const SizedBox(
        height: 0,
      ),
    );
  }

  // Build recommended spaces section
  Widget _buildRecommendedSpaces(
      AsyncValue<Map<String, List<Space>>> allSpaces) {
    return allSpaces.when(
      data: (spacesData) {
        // Combine all spaces from different categories
        List<Space> allSpacesList = [];
        spacesData.forEach((key, value) {
          allSpacesList.addAll(value);
        });

        if (allSpacesList.isEmpty) {
          return const SizedBox.shrink();
        }

        // Sort by engagement score (higher scores first)
        allSpacesList.sort((a, b) {
          final aEngagement = a.metrics.engagementScore;
          final bEngagement = b.metrics.engagementScore;
          return bEngagement.compareTo(aEngagement);
        });

        // Get top 10 spaces by engagement score
        final recommendedSpaces =
            allSpacesList.take(min(10, allSpacesList.length)).toList();

        if (recommendedSpaces.isEmpty) {
          return const SizedBox.shrink();
        }

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
              child: Row(
                children: [
                  const Icon(
                    Icons.recommend,
                    size: 18,
                    color: AppColors.gold,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    'Recommended for You',
                    style: GoogleFonts.outfit(
                      fontSize: 16,
                      fontWeight: FontWeight.w600,
                      color: Colors.white,
                    ),
                  ),
                ],
              ),
            ),
            SizedBox(
              height: 120,
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                padding: const EdgeInsets.only(left: 16, right: 8),
                itemCount: recommendedSpaces.length,
                itemBuilder: (context, index) {
                  final space = recommendedSpaces[index];

                  // Determine special label for this space
                  String? specialLabel;
                  Color? labelColor;

                  if (index == 0) {
                    specialLabel = "Best Match";
                    labelColor = Colors.purple[300];
                  } else if (index < 3 && Random().nextBool()) {
                    specialLabel = "High Match";
                    labelColor = Colors.blue[400];
                  } else if (Random().nextInt(3) == 0) {
                    specialLabel = "Major Match";
                    labelColor = Colors.blue[300];
                  } else {
                    specialLabel = "#${index + 1} Recommended";
                    labelColor = Colors.purple[300];
                  }

                  return Padding(
                    padding: const EdgeInsets.only(right: 12),
                    child: SizedBox(
                      width: 160,
                      child: AnimationConfiguration.staggeredList(
                        position: index,
                        duration: const Duration(milliseconds: 375),
                        child: SlideAnimation(
                          horizontalOffset: 50,
                          child: FadeInAnimation(
                            child: _buildRecommendedSpaceCard(
                              space,
                              specialLabel: specialLabel,
                              labelColor: labelColor,
                            ),
                          ),
                        ),
                      ),
                    ),
                  );
                },
              ),
            ),
            const SizedBox(height: 16),
          ],
        );
      },
      loading: () => const SizedBox(
        height: 0,
      ),
      error: (_, __) => const SizedBox(
        height: 0,
      ),
    );
  }

  // Build recommended space card with subtle difference from trending card
  Widget _buildRecommendedSpaceCard(
    Space space, {
    String? specialLabel,
    Color? labelColor,
  }) {
    final hasImage = space.imageUrl != null && space.imageUrl!.isNotEmpty;
    final isGreekLife =
        space.spaceType.toString().toLowerCase().contains('greek');

    return Container(
      clipBehavior: Clip.antiAlias,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        gradient: LinearGradient(
          colors: [
            Colors.grey[900]!.withOpacity(0.8),
            Colors.black.withOpacity(0.7),
          ],
          begin: Alignment.topRight,
          end: Alignment.bottomLeft,
        ),
        border: Border.all(
          color: AppColors.gold.withOpacity(0.2),
          width: 1,
        ),
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () => _handleTapSpace(space),
          splashColor: AppColors.gold.withOpacity(0.1),
          highlightColor: AppColors.gold.withOpacity(0.05),
          child: Stack(
            children: [
              // Background image with overlay
              if (hasImage)
                Positioned.fill(
                  child: Opacity(
                    opacity: 0.3,
                    child: CachedNetworkImage(
                      imageUrl: space.imageUrl!,
                      fit: BoxFit.cover,
                      errorWidget: (_, __, ___) => Center(
                        child: isGreekLife
                            ? const Icon(
                                Icons.groups,
                                color: Colors.white30,
                                size: 36,
                              )
                            : const Icon(
                                Icons.person,
                                color: Colors.white30,
                                size: 36,
                              ),
                      ),
                    ),
                  ),
                )
              // If no image, show icon as background
              else
                Positioned.fill(
                  child: Center(
                    child: isGreekLife
                        ? const Icon(
                            Icons.groups,
                            color: Colors.white24,
                            size: 36,
                          )
                        : const Icon(
                            Icons.person,
                            color: Colors.white24,
                            size: 36,
                          ),
                  ),
                ),

              // Content - space name only (no label)
              Padding(
                padding: const EdgeInsets.all(8),
                child: Center(
                  child: Text(
                    space.name,
                    style: GoogleFonts.outfit(
                      fontSize: 15,
                      fontWeight: FontWeight.w600,
                      color: Colors.white,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                    textAlign: TextAlign.center,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Redesigned space card with visual enhancements for trending spaces
  Widget _buildMySpaceCard(
    Space space, {
    int? trendingRank,
    String? specialLabel,
    Color? labelColor,
    bool hasGlowEffect = false,
  }) {
    final hasImage = space.imageUrl != null && space.imageUrl!.isNotEmpty;
    final isGreekLife =
        space.spaceType.toString().toLowerCase().contains('greek');

    // Create the label text
    String? labelText;
    if (specialLabel != null) {
      labelText = specialLabel;
    } else if (trendingRank != null) {
      labelText = "#$trendingRank Trending";
    }

    // Create a key unique to this space for the animation controller
    final key = ValueKey('trending_${space.id}');

    return Container(
      clipBehavior: Clip.antiAlias,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(16),
        gradient: LinearGradient(
          colors: [
            Colors.grey[900]!.withOpacity(0.5),
            Colors.black,
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        border: Border.all(
          color: hasGlowEffect
              ? AppColors.gold.withOpacity(0.5)
              : Colors.white.withOpacity(0.1),
          width: 1,
        ),
        boxShadow: hasGlowEffect
            ? [
                BoxShadow(
                  color: AppColors.gold.withOpacity(0.2),
                  blurRadius: 8,
                  spreadRadius: 1,
                )
              ]
            : null,
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () => _handleTapSpace(space),
          splashColor: AppColors.gold.withOpacity(0.1),
          highlightColor: AppColors.gold.withOpacity(0.05),
          child: Stack(
            children: [
              // Background image with overlay
              if (hasImage)
                Positioned.fill(
                  child: CachedNetworkImage(
                    imageUrl: space.imageUrl!,
                    fit: BoxFit.cover,
                    errorWidget: (_, __, ___) => Center(
                      child: isGreekLife
                          ? const Icon(
                              Icons.diversity_3,
                              color: Colors.white30,
                              size: 36,
                            )
                          : const Icon(
                              Icons.groups,
                              color: Colors.white30,
                              size: 36,
                            ),
                    ),
                  ),
                ),

              // Gradient overlay for better text readability
              Positioned.fill(
                child: Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                      colors: [
                        Colors.black.withOpacity(0.4),
                        Colors.black.withOpacity(0.8),
                      ],
                      stops: const [0.0, 0.8],
                    ),
                  ),
                ),
              ),

              // Content with improved layout
              Padding(
                padding: const EdgeInsets.all(12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Add top badge if trending
                    if (trendingRank != null && trendingRank <= 3)
                      Align(
                        alignment: Alignment.topRight,
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 8, vertical: 4),
                          decoration: BoxDecoration(
                            color: trendingRank == 1
                                ? AppColors.gold.withOpacity(0.8)
                                : Colors.orange.withOpacity(0.8),
                            borderRadius: BorderRadius.circular(12),
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              const Icon(
                                Icons.trending_up,
                                color: Colors.black,
                                size: 10,
                              ),
                              const SizedBox(width: 2),
                              Text(
                                trendingRank == 1 ? "HOT" : "#$trendingRank",
                                style: GoogleFonts.inter(
                                  fontSize: 9,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.black,
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),

                    const Spacer(),

                    // Space name with improved styling
                    Text(
                      space.name,
                      style: GoogleFonts.outfit(
                        fontSize: 16,
                        fontWeight: FontWeight.w600,
                        color: Colors.white,
                        letterSpacing: 0.2,
                        shadows: [
                          Shadow(
                            blurRadius: 3,
                            color: Colors.black.withOpacity(0.5),
                            offset: const Offset(0, 1),
                          ),
                        ],
                      ),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),

                    const SizedBox(height: 6),

                    // Member count
                    Row(
                      children: [
                        const Icon(
                          Icons.people_outlined,
                          size: 12,
                          color: Colors.white70,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          "${space.metrics.memberCount} members",
                          style: GoogleFonts.inter(
                            fontSize: 11,
                            color: Colors.white70,
                          ),
                        ),
                      ],
                    ),

                    // Label with animation
                    if (labelText != null &&
                        labelText.toLowerCase() != "popular")
                      Container(
                        margin: const EdgeInsets.only(top: 8),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 8, vertical: 4),
                        decoration: BoxDecoration(
                          color:
                              (labelColor ?? AppColors.gold).withOpacity(0.2),
                          borderRadius: BorderRadius.circular(4),
                          border: Border.all(
                            color:
                                (labelColor ?? AppColors.gold).withOpacity(0.3),
                            width: 1,
                          ),
                        ),
                        child: TweenAnimationBuilder<double>(
                          key: key,
                          tween: Tween<double>(begin: 0.0, end: 1.0),
                          duration: const Duration(milliseconds: 500),
                          builder: (context, value, child) {
                            return Opacity(
                              opacity: value,
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(
                                    labelText!.contains("Rising")
                                        ? Icons.rocket_launch
                                        : Icons.local_fire_department,
                                    size: 10,
                                    color: labelColor ?? AppColors.gold,
                                  ),
                                  const SizedBox(width: 4),
                                  Text(
                                    labelText,
                                    style: GoogleFonts.inter(
                                      fontSize: 10,
                                      fontWeight: FontWeight.w500,
                                      color: labelColor ?? AppColors.gold,
                                    ),
                                  ),
                                ],
                              ),
                            );
                          },
                        ),
                      ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // New list-style space item, optimized for mobile viewing
  Widget _buildSpaceListItem(Space space, int index,
      {bool inMySpaces = false}) {
    final hasImage = space.imageUrl != null && space.imageUrl!.isNotEmpty;
    final isGreekLife =
        space.spaceType.toString().toLowerCase().contains('greek');

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 6, 16, 6),
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          color: Colors.grey[900]!.withOpacity(0.3),
          border: Border.all(
            color: Colors.white.withOpacity(0.08),
            width: 1,
          ),
        ),
        clipBehavior: Clip.antiAlias,
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: () => _handleTapSpace(space),
            splashColor: AppColors.gold.withOpacity(0.1),
            highlightColor: AppColors.gold.withOpacity(0.05),
            child: Stack(
              children: [
                Padding(
                  padding:
                      const EdgeInsets.symmetric(vertical: 12, horizontal: 12),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Space image or placeholder
                      Hero(
                        tag: 'space_image_${space.id}',
                        child: Container(
                          width: 48,
                          height: 48,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(8),
                            color: Colors.black,
                            border: Border.all(
                              color: AppColors.gold.withOpacity(0.3),
                              width: 1,
                            ),
                          ),
                          clipBehavior: Clip.antiAlias,
                          child: hasImage
                              ? Image.network(
                                  space.imageUrl!,
                                  fit: BoxFit.cover,
                                  errorBuilder: (_, __, ___) => Center(
                                    child: isGreekLife
                                        ? const Icon(
                                            Icons.groups,
                                            color: Colors.white54,
                                            size: 24,
                                          )
                                        : const Icon(
                                            Icons.person,
                                            color: Colors.white54,
                                            size: 24,
                                          ),
                                  ),
                                )
                              : Center(
                                  child: isGreekLife
                                      ? const Icon(
                                          Icons.groups,
                                          color: Colors.white54,
                                          size: 24,
                                        )
                                      : const Icon(
                                          Icons.person,
                                          color: Colors.white54,
                                          size: 24,
                                        ),
                                ),
                        ),
                      ),
                      const SizedBox(width: 12),

                      // Space name only - with padding to avoid plus button overlap
                      Expanded(
                        child: Padding(
                          padding: EdgeInsets.only(
                              right: !inMySpaces ? 32 : 0, top: 2),
                          child: Text(
                            space.name,
                            style: GoogleFonts.outfit(
                              fontSize: 15,
                              fontWeight: FontWeight.w600,
                              color: Colors.white,
                              height: 1.3,
                            ),
                            maxLines: 3,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ),

                      // Arrow button for My Spaces
                      if (inMySpaces)
                        Padding(
                          padding: const EdgeInsets.only(top: 2),
                          child: IconButton(
                            icon: const Icon(
                              Icons.arrow_forward_ios_rounded,
                              size: 16,
                            ),
                            onPressed: () => _handleTapSpace(space),
                            color: AppColors.gold,
                            splashRadius: 20,
                            padding: EdgeInsets.zero,
                            constraints: const BoxConstraints(
                              minWidth: 28,
                              minHeight: 28,
                            ),
                          ),
                        ),
                    ],
                  ),
                ),

                // Quick-add button as a plus icon (only show in explore, not in My Spaces)
                if (!inMySpaces)
                  Positioned(
                    top: 0,
                    right: 0,
                    child: Material(
                      color: Colors.transparent,
                      child: InkWell(
                        onTap: () => _handleJoinSpace(space),
                        borderRadius: const BorderRadius.only(
                          bottomLeft: Radius.circular(16),
                          topRight: Radius.circular(12),
                        ),
                        child: Container(
                          padding: const EdgeInsets.all(8),
                          decoration: BoxDecoration(
                            color: Colors.black.withOpacity(0.6),
                            borderRadius: const BorderRadius.only(
                              bottomLeft: Radius.circular(16),
                              topRight: Radius.circular(12),
                            ),
                          ),
                          child: const Tooltip(
                            message: "Add to My Spaces",
                            child: Icon(
                              HugeIcons.strokeRoundedPlusSignCircle,
                              color: AppColors.gold,
                              size: 16,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  // Main spaces grid with filtered content - redesigned for better mobile experience
  Widget _buildSpacesGrid(AsyncValue<Map<String, List<Space>>> spacesMap) {
    return spacesMap.when(
      data: (spacesData) {
        // Get the recommended spaces IDs to filter them out from the main grid
        final recommendedSpaceIds = _getRecommendedSpaceIds(spacesData);

        // Filter spaces based on selected category
        List<Space> spaces = [];

        if (_activeCategory == 'All') {
          // Combine all spaces from different categories
          spacesData.forEach((key, value) {
            spaces.addAll(value);
          });
        } else {
          // Map the UI category to the data category
          String dataCategory;
          switch (_activeCategory) {
            case 'Student Orgs':
              dataCategory = 'Student Organizations';
              break;
            case 'University':
              dataCategory = 'University Groups';
              break;
            case 'Campus Living':
              dataCategory = 'Campus Living';
              break;
            case 'Greek Life':
              dataCategory = 'Greek Life';
              break;
            case 'Hive Exclusive':
              // For Hive Exclusive, gather all spaces first
              spacesData.forEach((key, value) {
                // Only add Hive Exclusive spaces
                spaces.addAll(value.where((space) => space.hiveExclusive));
              });
              dataCategory = ''; // Empty since we've already added the spaces
              break;
            default:
              dataCategory = 'Other Spaces';
          }

          // Get spaces from the selected category if not already filtered
          if (_activeCategory != 'Hive Exclusive') {
            spaces = spacesData[dataCategory] ?? [];
          }
        }

        // Apply search filter if needed
        final searchQuery = _searchController.text.toLowerCase();
        if (searchQuery.isNotEmpty) {
          spaces = spaces
              .where((space) =>
                  space.name.toLowerCase().contains(searchQuery) ||
                  space.description.toLowerCase().contains(searchQuery) ||
                  (space.tags
                      .any((tag) => tag.toLowerCase().contains(searchQuery))) ||
                  (space.spaceType
                      .toString()
                      .toLowerCase()
                      .contains(searchQuery)))
              .toList();
        }

        // Apply tag filters if any are active
        if (_activeFilters.isNotEmpty) {
          spaces = spaces
              .where((space) => (space.tags.any((tag) => _activeFilters.any(
                      (filter) =>
                          tag.toLowerCase().contains(filter.toLowerCase()))) ||
                  _activeFilters.any((filter) => space.spaceType
                      .toString()
                      .toLowerCase()
                      .contains(filter.toLowerCase()))))
              .toList();
        }

        // Filter out spaces that are in the recommended list
        spaces = spaces
            .where((space) => !recommendedSpaceIds.contains(space.id))
            .toList();

        // Sort spaces by engagement score
        spaces.sort((a, b) {
          // First prioritize spaces with higher engagement
          final aEngagement = a.metrics.engagementScore;
          final bEngagement = b.metrics.engagementScore;

          if (bEngagement != aEngagement) {
            return bEngagement.compareTo(aEngagement);
          }

          // Then alphabetically
          return a.name.compareTo(b.name);
        });

        if (spaces.isEmpty) {
          return SliverToBoxAdapter(
            child: Center(
              child: Padding(
                padding: const EdgeInsets.all(32.0),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    const Icon(
                      Icons.search,
                      size: 48,
                      color: Colors.white24,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'No spaces found',
                      style: GoogleFonts.outfit(
                        fontSize: 18,
                        fontWeight: FontWeight.w600,
                        color: Colors.white70,
                      ),
                    ),
                    if (searchQuery.isNotEmpty || _activeFilters.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(top: 8),
                        child: Text(
                          'Try adjusting your filters',
                          style: GoogleFonts.inter(
                            fontSize: 14,
                            color: Colors.white38,
                          ),
                        ),
                      ),
                  ],
                ),
              ),
            ),
          );
        }

        // Build grid of spaces
        return SliverPadding(
          padding: const EdgeInsets.fromLTRB(
              0, 8, 0, 120), // Add bottom padding for FAB
          sliver: SliverList(
            delegate: SliverChildBuilderDelegate(
              (context, index) {
                // Determine if we should add a section header
                if (index == 0) {
                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 8, 16, 12),
                        child: Row(
                          children: [
                            Text(
                              'All Spaces',
                              style: GoogleFonts.outfit(
                                fontSize: 18,
                                fontWeight: FontWeight.w600,
                                color: Colors.white,
                              ),
                            ),
                            const Spacer(),
                            // Filter icon to replace horizontal category selector
                            Container(
                              decoration: BoxDecoration(
                                color: Colors.grey[850]?.withOpacity(0.5),
                                borderRadius: BorderRadius.circular(8),
                                border: Border.all(
                                  color: _activeCategory != 'All' 
                                    ? AppColors.gold.withOpacity(0.5) 
                                    : Colors.transparent,
                                  width: 1,
                                ),
                              ),
                              child: InkWell(
                                onTap: () => _showCategoryFilterDialog(context),
                                borderRadius: BorderRadius.circular(8),
                                child: Padding(
                                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                  child: Row(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Icon(
                                        HugeIcons.tag,
                                        size: 16,
                                        color: _activeCategory != 'All' 
                                          ? AppColors.gold 
                                          : Colors.white70,
                                      ),
                                      const SizedBox(width: 6),
                                      Text(
                                        _activeCategory != 'All' ? _activeCategory : 'Filter',
                                        style: GoogleFonts.inter(
                                          fontSize: 13,
                                          fontWeight: _activeCategory != 'All' 
                                            ? FontWeight.w600 
                                            : FontWeight.w400,
                                          color: _activeCategory != 'All' 
                                            ? AppColors.gold 
                                            : Colors.white70,
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                            ),
                            // Add tag filter button - always visible
                            if (_activeCategory == 'Hive Exclusive')
                              Padding(
                                padding: const EdgeInsets.only(left: 8.0),
                                child: Container(
                                  decoration: BoxDecoration(
                                    color: Colors.grey[850]?.withOpacity(0.5),
                                    borderRadius: BorderRadius.circular(8),
                                    border: Border.all(
                                      color: _activeFilters.isNotEmpty
                                        ? AppColors.gold.withOpacity(0.5)
                                        : Colors.transparent,
                                      width: 1,
                                    ),
                                  ),
                                  child: InkWell(
                                    onTap: () => _showTagsFilterBottomSheet(context),
                                    borderRadius: BorderRadius.circular(8),
                                    child: Padding(
                                      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                                      child: Row(
                                        mainAxisSize: MainAxisSize.min,
                                        children: [
                                          Icon(
                                            Icons.local_offer,
                                            size: 16,
                                            color: _activeFilters.isNotEmpty
                                              ? AppColors.gold
                                              : Colors.white70,
                                          ),
                                          const SizedBox(width: 6),
                                          Text(
                                            _activeFilters.isNotEmpty ? 'Tags (${_activeFilters.length})' : 'Tags',
                                            style: GoogleFonts.inter(
                                              fontSize: 13,
                                              fontWeight: _activeFilters.isNotEmpty
                                                ? FontWeight.w600
                                                : FontWeight.w400,
                                              color: _activeFilters.isNotEmpty
                                                ? AppColors.gold
                                                : Colors.white70,
                                            ),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                          ],
                        ),
                      ),
                      // Add a subtle divider
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16),
                        child: Divider(
                          color: Colors.white.withOpacity(0.1),
                          height: 1,
                        ),
                      ),
                      const SizedBox(height: 8),
                    ],
                  );
                }

                final spaceIndex = index - 1;
                if (spaceIndex < spaces.length) {
                  return AnimationConfiguration.staggeredList(
                    position: spaceIndex,
                    duration: const Duration(milliseconds: 375),
                    child: SlideAnimation(
                      verticalOffset: 50,
                      child: FadeInAnimation(
                        child:
                            _buildSpaceListItem(spaces[spaceIndex], spaceIndex),
                      ),
                    ),
                  );
                }

                // Show loading indicator at the end if loading more
                if (spaceIndex == spaces.length && _isLoadingMore) {
                  return const Padding(
                    padding: EdgeInsets.symmetric(vertical: 16),
                    child: Center(
                      child: SizedBox(
                        width: 24,
                        height: 24,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: AppColors.gold,
                        ),
                      ),
                    ),
                  );
                }

                return null;
              },
              // +1 for the header, +1 for possible loading indicator
              childCount: spaces.length + 1 + (_isLoadingMore ? 1 : 0),
            ),
          ),
        );
      },
      loading: () => const SliverFillRemaining(
        child: Center(
          child: CircularProgressIndicator(color: AppColors.gold),
        ),
      ),
      error: (_, __) => SliverToBoxAdapter(
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(32.0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.error_outline,
                  size: 48,
                  color: Colors.red[300],
                ),
                const SizedBox(height: 16),
                Text(
                  'Error loading spaces',
                  style: GoogleFonts.outfit(
                    fontSize: 18,
                    fontWeight: FontWeight.w600,
                    color: Colors.white,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'Please try again later',
                  style: GoogleFonts.inter(
                    fontSize: 14,
                    color: Colors.white70,
                  ),
                ),
                const SizedBox(height: 24),
                OutlinedButton(
                  onPressed: _refreshSpaces,
                  style: OutlinedButton.styleFrom(
                    foregroundColor: AppColors.gold,
                    side: const BorderSide(color: AppColors.gold),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(8),
                    ),
                    padding:
                        const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  ),
                  child: Text(
                    'Retry',
                    style: GoogleFonts.inter(fontWeight: FontWeight.w500),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  // Add a method to show the category filter dialog
  void _showCategoryFilterDialog(BuildContext context) {
    // Use a full-screen dialog approach that completely covers the navigation bar
    showDialog(
      context: context,
      barrierDismissible: true,
      barrierColor: Colors.black.withOpacity(0.5),
      useSafeArea: false, // Very important to disable safe area
      builder: (dialogContext) => Dialog(
        insetPadding: EdgeInsets.zero, // Remove any padding
        backgroundColor: Colors.transparent,
        child: Container(
          width: double.infinity,
          height: double.infinity,
          alignment: Alignment.bottomCenter,
          // This will ensure we capture taps outside the bottom sheet to dismiss
          child: GestureDetector(
            onTap: () => Navigator.pop(context),
            behavior: HitTestBehavior.opaque,
            child: Container(
              color: Colors.transparent,
              child: GestureDetector(
                onTap: () {}, // Prevent taps from propagating through the bottom sheet
                child: Container(
                  height: MediaQuery.of(context).size.height * 0.7,
                  width: double.infinity,
                  decoration: BoxDecoration(
                    color: Colors.grey[900],
                    borderRadius: const BorderRadius.only(
                      topLeft: Radius.circular(16),
                      topRight: Radius.circular(16),
                    ),
                    border: Border.all(
                      color: AppColors.gold.withOpacity(0.2),
                      width: 1,
                    ),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Handle
                      Center(
                        child: Container(
                          margin: const EdgeInsets.only(top: 12, bottom: 8),
                          width: 40,
                          height: 4,
                          decoration: BoxDecoration(
                            color: Colors.white.withOpacity(0.3),
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                      ),
                      Padding(
                        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 20),
                        child: Row(
                          children: [
                            Text(
                              'Filter Spaces',
                              style: GoogleFonts.outfit(
                                fontSize: 18,
                                fontWeight: FontWeight.w600,
                                color: Colors.white,
                              ),
                            ),
                            const Spacer(),
                            if (_activeCategory != 'All')
                              TextButton(
                                onPressed: () {
                                  setState(() {
                                    _activeCategory = 'All';
                                  });
                                  Navigator.pop(context);
                                },
                                child: Text(
                                  'Reset',
                                  style: GoogleFonts.inter(
                                    color: AppColors.gold,
                                    fontSize: 14,
                                  ),
                                ),
                              ),
                          ],
                        ),
                      ),
                      const Divider(color: Colors.white12),
                      Expanded(
                        child: ListView.builder(
                          shrinkWrap: true,
                          padding: const EdgeInsets.only(
                            top: 8,
                            bottom: 80, // Extra padding to ensure content is visible above nav bar
                          ),
                          itemCount: _categories.length,
                          itemBuilder: (context, index) {
                            final category = _categories[index];
                            final isActive = _activeCategory == category;
                            
                            // Assign appropriate icon based on category
                            IconData categoryIcon = Icons.category;
                            switch (category) {
                              case 'All':
                                categoryIcon = HugeIcons.home;
                                break;
                              case 'Student Orgs':
                                categoryIcon = HugeIcons.strokeRoundedUserGroup03;
                                break;
                              case 'Greek Life':
                                categoryIcon = HugeIcons.strokeRoundedAlphabetGreek;
                                break;
                              case 'Campus Living':
                                categoryIcon = HugeIcons.strokeRoundedHouse03;
                                break;
                              case 'University':
                                categoryIcon = HugeIcons.strokeRoundedMortarboard02;
                                break;
                              case 'Hive Exclusive':
                                categoryIcon = Icons.workspace_premium;
                                break;
                            }
                            
                            return InkWell(
                              onTap: () {
                                // Disable tap for locked categories
                                if (category == 'Academics' || category == 'Circles') {
                                  HapticFeedback.heavyImpact();
                                  return;
                                }
                                
                                HapticFeedback.selectionClick();
                                setState(() {
                                  // Store the previous category
                                  final previousCategory = _activeCategory;
                                  // Set the new category
                                  _activeCategory = category;
                                  
                                  // Don't clear filters when switching to Hive Exclusive
                                  // or when previously on Hive Exclusive and switching to another category
                                  // This preserves filter options across category changes
                                });
                                Navigator.pop(context);
                                
                                // Animate scroll to top when changing categories
                                if (_mainScrollController.hasClients) {
                                  _mainScrollController.animateTo(
                                    0,
                                    duration: const Duration(milliseconds: 300),
                                    curve: Curves.easeInOut,
                                  );
                                }
                              },
                              child: Padding(
                                padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 20),
                                child: Row(
                                  children: [
                                    // Show different icons based on category
                                    if (category == 'Hive Exclusive')
                                      Image.asset(
                                        'assets/images/hivelogo.png',
                                        width: 20,
                                        height: 20,
                                        color: isActive ? AppColors.gold : Colors.white70,
                                      )
                                    else if (category == 'Academics')
                                      Icon(
                                        HugeIcons.strokeRoundedBook02,
                                        color: Colors.white30,
                                        size: 20,
                                      )
                                    else if (category == 'Circles')
                                      Icon(
                                        HugeIcons.strokeRoundedUserGroup03,
                                        color: Colors.white30,
                                        size: 20,
                                      )
                                    else
                                      Icon(
                                        categoryIcon,
                                        color: isActive ? AppColors.gold : Colors.white70,
                                        size: 20,
                                      ),
                                    const SizedBox(width: 16),
                                    Text(
                                      category,
                                      style: GoogleFonts.outfit(
                                        fontSize: 16,
                                        color: (category == 'Academics' || category == 'Circles')
                                            ? Colors.white38
                                            : (isActive ? AppColors.gold : Colors.white),
                                        fontWeight: isActive ? FontWeight.w600 : FontWeight.w400,
                                      ),
                                    ),
                                    const Spacer(),
                                    if (isActive)
                                      const Icon(
                                        Icons.check_circle,
                                        color: AppColors.gold,
                                        size: 20,
                                      )
                                    else if (category == 'Academics' || category == 'Circles')
                                      const Icon(
                                        Icons.lock,
                                        color: Colors.white30,
                                        size: 16,
                                      ),
                                  ],
                                ),
                              ),
                            );
                          },
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showTagsFilterBottomSheet(BuildContext context) {
    showModalBottomSheet(
    );
  }

  void _showTagsFilterBottomSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) {
        return Container(
          decoration: BoxDecoration(
            color: AppColors.black.withOpacity(0.95),
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(16),
              topRight: Radius.circular(16),
            ),
          ),
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  'Filter Spaces',
                  style: GoogleFonts.outfit(
                    color: AppColors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 16),
                // Add filter options here
                Text(
                  'Coming soon: Filter by tags',
                  style: GoogleFonts.inter(
                    color: AppColors.textSecondary,
                    fontSize: 16,
                  ),
                ),
                const SizedBox(height: 16),
              ],
            ),
          ),
        );
      },
    );
  }

  // Show dialog to create a new space
  void _showCreateSpaceDialog(BuildContext context) {
    HapticFeedback.mediumImpact();
    
    final nameController = TextEditingController();
    final descriptionController = TextEditingController();
    
    showDialog(
      context: context,
      barrierColor: Colors.black.withOpacity(0.8),
      builder: (context) => Dialog(
        backgroundColor: Colors.grey[900],
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        child: Container(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Create New Space',
                style: GoogleFonts.outfit(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white,
                ),
              ),
              const SizedBox(height: 24),
              TextField(
                controller: nameController,
                style: GoogleFonts.inter(color: Colors.white),
                decoration: InputDecoration(
                  labelText: 'Space Name',
                  labelStyle: GoogleFonts.inter(color: Colors.white70),
                  hintText: 'Enter a name for your space',
                  hintStyle: GoogleFonts.inter(color: Colors.white30),
                  filled: true,
                  fillColor: Colors.black.withOpacity(0.3),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: Colors.white.withOpacity(0.1)),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: Colors.white.withOpacity(0.1)),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: const BorderSide(color: AppColors.gold),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              TextField(
                controller: descriptionController,
                style: GoogleFonts.inter(color: Colors.white),
                maxLines: 3,
                decoration: InputDecoration(
                  labelText: 'Description',
                  labelStyle: GoogleFonts.inter(color: Colors.white70),
                  hintText: 'What is this space about?',
                  hintStyle: GoogleFonts.inter(color: Colors.white30),
                  filled: true,
                  fillColor: Colors.black.withOpacity(0.3),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: Colors.white.withOpacity(0.1)),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: BorderSide(color: Colors.white.withOpacity(0.1)),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                    borderSide: const BorderSide(color: AppColors.gold),
                  ),
                ),
              ),
              const SizedBox(height: 24),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: () => Navigator.pop(context),
                    style: TextButton.styleFrom(
                      foregroundColor: Colors.white,
                    ),
                    child: Text('Cancel', style: GoogleFonts.inter()),
                  ),
                  const SizedBox(width: 16),
                  ElevatedButton(
                    onPressed: () {
                      if (nameController.text.trim().isNotEmpty) {
                        Navigator.pop(context);
                        _createNewSpace(
                          nameController.text.trim(),
                          descriptionController.text.trim(),
                        );
                      }
                    },
                    style: ElevatedButton.styleFrom(
                      backgroundColor: AppColors.gold,
                      foregroundColor: Colors.black,
                      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8),
                      ),
                    ),
                    child: Text(
                      'Create',
                      style: GoogleFonts.inter(fontWeight: FontWeight.w600),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Create a new space
  Future<void> _createNewSpace(String name, String description) async {
    if (name.isEmpty) return;
    
    // Show loading indicator
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Creating your space...'),
        duration: Duration(seconds: 2),
      ),
    );
    
    try {
      // Get current user ID
      final userId = FirebaseAuth.instance.currentUser?.uid;
      if (userId == null) throw Exception('User not authenticated');
      
      // Create space in Firestore
      final spaceId = FirebaseFirestore.instance.collection('spaces').doc().id;
      
      await FirebaseFirestore.instance.collection('spaces').doc(spaceId).set({
        'name': name,
        'description': description,
        'createdBy': userId,
        'admins': [userId],
        'moderators': [],
        'members': [userId],
        'tags': [],
        'isPrivate': false,
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      // Add user to space
      await FirebaseFirestore.instance.collection('users').doc(userId).update({
        'followedSpaces': FieldValue.arrayUnion([spaceId]),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      
      // Show success message
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Space "$name" created successfully!'),
          backgroundColor: Colors.green[700],
          duration: const Duration(seconds: 2),
        ),
      );
      
      // Refresh spaces
      _refreshSpaces();
      
    } catch (e) {
      // Show error message
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to create space: ${e.toString()}'),
          backgroundColor: Colors.red[700],
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }
}

// Keeping _SliverCategorySelectorDelegate for category selector
class _SliverCategorySelectorDelegate extends SliverPersistentHeaderDelegate {
  final Widget child;
  final bool visible;

  _SliverCategorySelectorDelegate({
    required this.child,
    this.visible = true,
  });

  @override
  double get minExtent =>
      visible ? 56 : 0; // Updated height for better touch targets

  @override
  double get maxExtent => visible ? 56 : 0; // Updated height for consistency

  @override
  Widget build(
      BuildContext context, double shrinkOffset, bool overlapsContent) {
    return visible ? child : const SizedBox.shrink();
  }

  @override
  bool shouldRebuild(_SliverCategorySelectorDelegate oldDelegate) {
    return child != oldDelegate.child || visible != oldDelegate.visible;
  }
}

// Helper method to get the IDs of all recommended spaces
Set<String> _getRecommendedSpaceIds(Map<String, List<Space>> spacesData) {
  // Combine all spaces from different categories
  List<Space> allSpacesList = [];
  spacesData.forEach((key, value) {
    allSpacesList.addAll(value);
  });

  if (allSpacesList.isEmpty) {
    return {};
  }

  // Sort by engagement score
  allSpacesList.sort((a, b) {
    final aEngagement = a.metrics.engagementScore;
    final bEngagement = b.metrics.engagementScore;
    return bEngagement.compareTo(aEngagement);
  });

  // Get top 10 spaces (or fewer if list is smaller)
  final recommendedSpaces =
      allSpacesList.take(min(10, allSpacesList.length)).toList();

  // Return the set of IDs
  return recommendedSpaces.map((space) => space.id).toSet();
}

// Widget that shows text temporarily and then hides it
class TemporaryText extends StatefulWidget {
  final String text;
  final TextStyle textStyle;
  final Duration displayDuration;
  final Duration hideDuration;

  const TemporaryText({
    super.key,
    required this.text,
    required this.textStyle,
    required this.displayDuration,
    required this.hideDuration,
  });

  @override
  State<TemporaryText> createState() => _TemporaryTextState();
}

class _TemporaryTextState extends State<TemporaryText> {
  bool _visible = true;

  @override
  void initState() {
    super.initState();
    _startCycle();
  }

  void _startCycle() async {
    await Future.delayed(widget.displayDuration);
    if (!mounted) return;

    setState(() {
      _visible = false;
    });

    await Future.delayed(widget.hideDuration);
    if (!mounted) return;

    setState(() {
      _visible = true;
    });

    _startCycle();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedOpacity(
      opacity: _visible ? 1.0 : 0.0,
      duration: const Duration(milliseconds: 800),
      child: Padding(
        padding: const EdgeInsets.only(top: 4),
        child: Text(
          widget.text,
          style: widget.textStyle,
          textAlign: TextAlign.center,
        ),
      ),
    );
  }
}

